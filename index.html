<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Bakeoff 2</title>
		<style type="text/css">
		/*		This CSS is not required, but recommended.	*/
			body {
				height: 100vh;
				width: 100vw;
				border: none;
				margin: 0px;
				text-align: center;
				display: flex;
			    align-items: center;
			    justify-content: center;
			}
			body.active {
				border-left: 3px #f06 solid;
			}
			footer {
				width: 100vw;
				text-align: center;
				position: absolute;
				bottom: 0px;
				padding: 0.75em;
				border-top: 1px #ddd solid;
			}
			svg {
				border: 1px #ddd solid;
			}
		</style>
		<!-- Two required scripts -->
		<script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.0/dist/svg.min.js"></script>
		<script src="https://dhcs-s25-bakeoff2.glitch.me/framework.js"></script>
		<!-- <script src="./js/framework.js"></script> -->
	</head>
	<body>
		<div id="main"></div>
	</body>
	<script type="text/javascript">
		// =========== This part is required: =========== 
		// This constant can be changed while you are experimenting, but it should be set back to 10 for the Bakeoff:
		const tasksLength = 10;

		// As with Bakeoff 1, this code uses the svg.js library; documentation at: https://svgjs.dev/docs/3.0/
		// Create an svg div that is the specified size, in the div with ID "main". (Centering it on the page is handled by CSS.)
		// The "size" attribute here is specified as a string.
		let svg = SVG().addTo('#main').size(""+canvasSize+"px", ""+canvasSize+"px");

		// Initialize the "judge" object with the number of tasks per trial, your svg drawing area, and a team name.
		const judge = new Judge(tasksLength, svg, "teamName");
		// =========== /end required =========== 

		// Events you can assign handlers to:
		// 		score: when a task is scored
		// 		newTask: when a new task (the set of start and goal positions) is created
		// 		testOver: when all tasks have been fulfilled
		// 		setup: when the judge is first created, and whenever the "reset" button is pressed
		// 		clearField: when the judge removes the squares from the previous round
		// judge.on(eventName, callback) will allow you to register a callback (handler) to any of the above.

		// Other functions you can call:
		// judge.getCurrentTask() will return a "task" object shaped like this:
		//		{
		//			start: {
		//				position: {
		//						x: number,
		//						y: number
		//					},
		//				rotation: number,
		//				size: number,
		//				square: SVG.Rect
		//			},
		//			goal: {
		//				position: {
		//					x: number,
		//					y: number
		//				},
		//				rotation: number,
		//				size: number,
		//				square: SVG.Rect
		//			}
		//		};
		// 
		// judge.getTaskNumber() will return the number (integer) of the current task
		// judge.setup() starts everything in motion.


		//  =========== !!! FOR EXAMPLE !!! =========== 

		// Here are some consts just for this example code:
		const startColor = "#6677ee";
		const goalColor = "#777";

		// And a global variable for dragging
		let squareBeingClicked = false;
		let resizeMode = false;
		let originalSize = 0;
		let startDragPos = { x: 0, y: 0 };
		let resizeHandle = null;
		const MIN_SQUARE_SIZE = 30; // Minimum square size to prevent scaling issues

		// These "SVG groups" will hold the squares. I could put other things in these groups, and then everything would move together.
		let manipulator = svg.group();
		let goal = svg.group();

		// Function to update the resize handle position
		function updateResizeHandlePosition() {
			const task = judge.getCurrentTask();
			if (!task || !resizeHandle) return;
			
			// Get the square's properties
			const square = task.start.square;
			const squareSize = square.width();
			
			// Get the bounding box to find the bottom-right corner
			const bbox = square.bbox();
			const bottomRightX = bbox.x + bbox.width;
			const bottomRightY = bbox.y + bbox.height;
			
			// Position the resize handle at the bottom right corner
			// Position it 8px from the corner to ensure it's visible
			resizeHandle.move(
				bottomRightX - 18, 
				bottomRightY - 18
			);
		}

		// Any time the mouse moves over the svg area...
		svg.on("mousemove", (e)=>{
			if (squareBeingClicked) {
				if (resizeMode) {
					// Handle resizing
					const task = judge.getCurrentTask();
					const dx = e.clientX - startDragPos.x;
					const dy = e.clientY - startDragPos.y;
					
					// Calculate new size based on the maximum change in either direction
					// This keeps the resize more controlled and predictable
					const dragDistance = Math.max(dx, dy);
					
					// Apply the new size with a minimum limit to prevent scaling issues
					const newSize = Math.max(MIN_SQUARE_SIZE, originalSize + dragDistance);
					
					// Resize the square
					task.start.square.size(newSize, newSize);
					
					// Update resize handle position
					updateResizeHandlePosition();
				} else {
					// Handle moving
					const task = judge.getCurrentTask();
					const squareSize = task.start.square.width();
					
					// Position the square so its top-right corner is at the cursor
					const point = svg.point(e.clientX, e.clientY);
					manipulator.move(point.x - squareSize, point.y);
					
					// Update resize handle position
					updateResizeHandlePosition();
				}
			}
		})

		// When a new task is assigned, run this...
		judge.on("newTask", () => {
			// get the next task
			let task = judge.getCurrentTask();

			// style the start and goal squares
			task.start.square.fill(startColor);
			task.goal.square.fill('none');
			task.goal.square.stroke(goalColor);

			// add the new squares to the groups
			manipulator.add(task.start.square);
			goal.add(task.goal.square);
			
			// Remove existing resize handle if it exists
			if (resizeHandle) {
				resizeHandle.remove();
			}
			
			// Create the resize handle - a small red box with diagonal dashed lines
			resizeHandle = svg.group();
			
			// Background box
			const handleBg = svg.rect(18, 18)
				.fill('#ff0000')
				.opacity(0.8)
				.radius(2);
			
			// Add diagonal dashed lines
			const diag1 = svg.line(3, 15, 15, 3)
				.stroke({ color: 'white', width: 1.5, dasharray: '2,1' });
			const diag2 = svg.line(6, 15, 15, 6)
				.stroke({ color: 'white', width: 1.5, dasharray: '2,1' });
			const diag3 = svg.line(9, 15, 15, 9)
				.stroke({ color: 'white', width: 1.5, dasharray: '2,1' });
			
			// Add the elements to the handle group
			resizeHandle.add(handleBg);
			resizeHandle.add(diag1);
			resizeHandle.add(diag2);
			resizeHandle.add(diag3);
			
			// Add the handle to the manipulator group
			manipulator.add(resizeHandle);
			
			// Position the handle at the bottom right corner
			updateResizeHandlePosition();

			// Add mousedown handler to the entire SVG canvas
			svg.on("mousedown", (e)=> {
				const point = svg.point(e.clientX, e.clientY);
				const square = task.start.square;
				const squareSize = task.start.size;
				
				// Check if we're clicking on the resize handle
				const handleBounds = resizeHandle.bbox();
				if (point.x >= handleBounds.x && point.x <= handleBounds.x + handleBounds.width &&
					point.y >= handleBounds.y && point.y <= handleBounds.y + handleBounds.height) {
					// Start resize mode
					resizeMode = true;
					originalSize = squareSize;
					startDragPos = { x: e.clientX, y: e.clientY };
				} else {
					// Start move mode
					resizeMode = false;
					
					// Position the square so its top-right corner is at the cursor
					manipulator.move(point.x - squareSize, point.y);
					
					// Update resize handle position
					updateResizeHandlePosition();
				}
				
				squareBeingClicked = true;
			});

			svg.on("mouseup", (e)=> {
				squareBeingClicked = false;
				resizeMode = false;
			});
		});

		// once you've got your handlers set up, start it up:
		judge.setup();
		
		// Add this helper function to find the bottom right corner
		function getBottomRightCorner(corners) {
			// Find the corner with the largest sum of x and y coordinates
			return corners.reduce((bottomRight, vertex) => {
				// Compare using the sum of x and y
				return (vertex.x + vertex.y > bottomRight.x + bottomRight.y) ? vertex : bottomRight;
			}, corners[0]);
		}

		// Helper function for transforming points with a matrix
		function transformPoint(point, matrix) {
			return {
				x: matrix.a * point.x + matrix.c * point.y + matrix.e,
				y: matrix.b * point.x + matrix.d * point.y + matrix.f
			};
		}
	</script>
</html>