<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Bakeoff 2</title>
		<style type="text/css">
		/*		This CSS is not required, but recommended.	*/
			body {
				height: 100vh;
				width: 100vw;
				border: none;
				margin: 0px;
				text-align: center;
				display: flex;
			    align-items: center;
			    justify-content: center;
			}
			body.active {
				border-left: 3px #f06 solid;
			}
			footer {
				width: 100vw;
				text-align: center;
				position: absolute;
				bottom: 0px;
				padding: 0.75em;
				border-top: 1px #ddd solid;
			}
			svg {
				border: 1px #ddd solid;
			}
		</style>
		<!-- Two required scripts -->
		<script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.0/dist/svg.min.js"></script>
		<script src="https://dhcs-s25-bakeoff2.glitch.me/framework.js"></script>
		<!-- <script src="./js/framework.js"></script> -->
	</head>
	<body>
		<div id="main"></div>
	</body>
	<script type="text/javascript">
		// =========== This part is required: =========== 
		// This constant can be changed while you are experimenting, but it should be set back to 10 for the Bakeoff:
		const tasksLength = 10;

		// As with Bakeoff 1, this code uses the svg.js library; documentation at: https://svgjs.dev/docs/3.0/
		// Create an svg div that is the specified size, in the div with ID "main". (Centering it on the page is handled by CSS.)
		// The "size" attribute here is specified as a string.
		let svg = SVG().addTo('#main').size(""+canvasSize+"px", ""+canvasSize+"px");

		// Initialize the "judge" object with the number of tasks per trial, your svg drawing area, and a team name.
		const judge = new Judge(tasksLength, svg, "teamName");
		// =========== /end required =========== 

		// Events you can assign handlers to:
		// 		score: when a task is scored
		// 		newTask: when a new task (the set of start and goal positions) is created
		// 		testOver: when all tasks have been fulfilled
		// 		setup: when the judge is first created, and whenever the "reset" button is pressed
		// 		clearField: when the judge removes the squares from the previous round
		// judge.on(eventName, callback) will allow you to register a callback (handler) to any of the above.

		// Other functions you can call:
		// judge.getCurrentTask() will return a "task" object shaped like this:
		//		{
		//			start: {
		//				position: {
		//						x: number,
		//						y: number
		//					},
		//				rotation: number,
		//				size: number,
		//				square: SVG.Rect
		//			},
		//			goal: {
		//				position: {
		//					x: number,
		//					y: number
		//				},
		//				rotation: number,
		//				size: number,
		//				square: SVG.Rect
		//			}
		//		};
		// 
		// judge.getTaskNumber() will return the number (integer) of the current task
		// judge.setup() starts everything in motion.


		//  =========== !!! FOR EXAMPLE !!! =========== 

		// Here are some consts just for this example code:
		const startColor = "#6677ee";
		const goalColor = "#777";

		// And global variables for interaction
		let squareBeingClicked = false;
		let resizeMode = false;
		let rotateMode = false;
		let alignMode = false;  // New variable to track alignment mode
		let originalSize = 0;
		let startDragPos = { x: 0, y: 0 };
		let centerPoint = { x: 0, y: 0 };
		let startRotation = 0;
		let resizeHandle = null;
		const MIN_SQUARE_SIZE = 30;

		// Add keyboard event listener for 'a' key
		document.addEventListener('keydown', (e) => {
			if (e.key.toLowerCase() === 'a') {
				alignMode = true;
			}
		});

		document.addEventListener('keyup', (e) => {
			if (e.key.toLowerCase() === 'a') {
				alignMode = false;
			}
		});

		// These "SVG groups" will hold the squares. I could put other things in these groups, and then everything would move together.
		let manipulator = svg.group();
		let goal = svg.group();

		// Function to get the topmost corner of a rotated square
		function getTopmostCorner(square) {
			const bbox = square.bbox();
			const rotation = square.transform().rotate;
			
			// Get all four corners
			const corners = [
				{x: bbox.x, y: bbox.y},                         // top-left
				{x: bbox.x + bbox.width, y: bbox.y},           // top-right
				{x: bbox.x, y: bbox.y + bbox.height},          // bottom-left
				{x: bbox.x + bbox.width, y: bbox.y + bbox.height}  // bottom-right
			];
			
			// Find the corner with the smallest y value (closest to top)
			return corners.reduce((topCorner, corner) => {
				return corner.y < topCorner.y ? corner : topCorner;
			}, corners[0]);
		}

		// When a new task is assigned, run this...
		judge.on("newTask", () => {
			// get the next task
			let task = judge.getCurrentTask();

			// style the start and goal squares
			task.start.square.fill(startColor);
			task.goal.square.fill('none');
			task.goal.square.stroke(goalColor);

			// Create a group for the square
			let squareGroup = svg.group();
			squareGroup.add(task.start.square);

			// add the groups
			manipulator.add(squareGroup);
			goal.add(task.goal.square);

			// Create the resize handle at the bottom of the screen
			if (resizeHandle) resizeHandle.remove();
			resizeHandle = svg.group();
			
			// Background box
			const handleBg = svg.rect(18, 18)
				.fill('#ff0000')
				.opacity(0.8)
				.radius(2);
			
			// Add diagonal lines
			const diag1 = svg.line(3, 15, 15, 3)
				.stroke({ color: 'white', width: 1.5, dasharray: '2,1' });
			const diag2 = svg.line(6, 15, 15, 6)
				.stroke({ color: 'white', width: 1.5, dasharray: '2,1' });
			const diag3 = svg.line(9, 15, 15, 9)
				.stroke({ color: 'white', width: 1.5, dasharray: '2,1' });
			
			// Add "R" text
			const rotateText = svg.text("R")
				.font({ size: 8, anchor: 'middle' })
				.fill('white')
				.center(9, 9);
			
			resizeHandle.add(handleBg);
			resizeHandle.add(diag1);
			resizeHandle.add(diag2);
			resizeHandle.add(diag3);
			resizeHandle.add(rotateText);
			
			// Position handle at bottom of screen
			const handleX = canvasSize /2;  // 20px from left
			const handleY = canvasSize - 40;  // 40px from bottom
			resizeHandle.move(handleX, handleY);
			
			// Add the handle directly to the svg, not to the square group
			svg.add(resizeHandle);

			// Add click handler to the SVG for alignment mode
			svg.on("click", (e) => {
				if (alignMode) {
					const task = judge.getCurrentTask();
					const squareSize = task.start.square.width();
					
					// To align top-right corner with cursor:
					// Move center left by half width to push right edge to cursor
					// Move center down by half height to push top edge to cursor
					manipulator.center(e.offsetX - squareSize/2, e.offsetY + squareSize/2);
				}
			});
			// Modify mousedown handler to initialize rotation tracking
			svg.on("mousedown", (e)=> {
				if (alignMode) {
					return;
				}

				const point = svg.point(e.clientX, e.clientY);
				const square = task.start.square;
				const squareSize = square.width();
				
				const handleBounds = resizeHandle.bbox();
				if (point.x >= handleBounds.x && point.x <= handleBounds.x + handleBounds.width &&
					point.y >= handleBounds.y && point.y <= handleBounds.y + handleBounds.height) {
					
					if (e.shiftKey) {
						rotateMode = true;
						resizeMode = false;
						
						const squareBox = square.rbox();
						centerPoint = {
							x: squareBox.x + squareBox.width/2,
							y: squareBox.y + squareBox.height/2
						};
						
						// Initialize rotation tracking
						startDragPos = { 
							x: e.clientX, 
							y: e.clientY,
							originalX: e.clientX,
							originalY: e.clientY,
							originalRotation: square.transform().rotate || 0
						};
					} else {
						rotateMode = false;
						resizeMode = true;
						originalSize = squareSize;
						startDragPos = { x: e.clientX, y: e.clientY };
					}
					squareBeingClicked = true;
				} else {
					// Check if clicking on the square
					const squareBounds = square.rbox();
					if (point.x >= squareBounds.x && point.x <= squareBounds.x + squareBounds.width &&
						point.y >= squareBounds.y && point.y <= squareBounds.y + squareBounds.height) {
						// Regular dragging mode only when clicking on square
						rotateMode = false;
						resizeMode = false;
						squareBeingClicked = true;
					} else {
						// Clicked outside square - no dragging
						squareBeingClicked = false;
					}
				}
			});

			// Update mouseup handler to clear rotation tracking
			svg.on("mouseup", (e)=> {
				squareBeingClicked = false;
				resizeMode = false;
				rotateMode = false;
				
				// Clear rotation tracking
				if (startDragPos) {
					delete startDragPos.originalX;
					delete startDragPos.originalY;
					delete startDragPos.originalRotation;
				}
			});
			
			// Instructions for alignment 
			const alignInstructions = svg.text("Press 'A' + click to align top-right corner (release 'A' to drag)")
				.font({ size: 10 })
				.fill('#555')
				.move(10, canvasSize - 60);
			
			// Instructions for rotation
			const instructions = svg.text("Hold SHIFT + drag red handle left and right for rotation")
				.font({ size: 10 })
				.fill('#555')
				.move(10, canvasSize - 40);
			
			// Add instructions for dragging
			const dragInstructions = svg.text("Click within the blue square to drag it")
				.font({ size: 10 })
				.fill('#555')
				.move(10, canvasSize - 20);
		});

		// once you've got your handlers set up, start it up:
		judge.setup();
		
		// Add this helper function to find the bottom right corner
		function getBottomRightCorner(corners) {
			// Find the corner with the largest sum of x and y coordinates
			return corners.reduce((bottomRight, vertex) => {
				// Compare using the sum of x and y
				return (vertex.x + vertex.y > bottomRight.x + bottomRight.y) ? vertex : bottomRight;
			}, corners[0]);
		}

		// Helper function for transforming points with a matrix
		function transformPoint(point, matrix) {
			return {
				x: matrix.a * point.x + matrix.c * point.y + matrix.e,
				y: matrix.b * point.x + matrix.d * point.y + matrix.f
			};
		}

		// Remove the updateResizeHandlePosition function since we don't need it anymore
		svg.on("mousemove", (e)=>{
  if (squareBeingClicked && !alignMode) { // Only allow dragging when not in align mode
    if (rotateMode) {
      const task = judge.getCurrentTask();
      const square = task.start.square;
      
      // Initialize original position and rotation if not set
      if (!startDragPos.originalX) {
        startDragPos.originalX = e.clientX;
        startDragPos.originalY = e.clientY;
        startDragPos.originalRotation = square.transform().rotate || 0;
      }
      
      // Calculate total movement from starting position
      const dx = e.clientX - startDragPos.originalX;
      
      // Even smaller scale factor for extremely precise rotation
      const rotationScale = 0.02; // 0.02 degrees per pixel moved
      
      // Calculate absolute rotation based on total movement
      const newRotation = startDragPos.originalRotation + (dx * rotationScale);
      
      // Apply rotation
      square.rotate(newRotation);
      task.start.rotation = newRotation;
    }
    else if (resizeMode) {
      const task = judge.getCurrentTask();
      const dx = e.clientX - startDragPos.x;
      
      //drag horizontally for scaling 
      const newSize = Math.max(MIN_SQUARE_SIZE, originalSize + dx);
      
      task.start.square.size(newSize, newSize);
    } else {
      const task = judge.getCurrentTask();
      const square = task.start.square;
      const squareSize = square.width();
      
      // Calculate bounds to keep square fully visible
      const halfSize = squareSize / 2;
      const minX = halfSize;
      const maxX = canvasSize - halfSize;
      const minY = halfSize;
      const maxY = canvasSize - halfSize;
      
      // Clamp the position within bounds
      const newX = Math.min(Math.max(e.offsetX, minX), maxX);
      const newY = Math.min(Math.max(e.offsetY, minY), maxY);
      
      manipulator.center(newX, newY);
    }
  }
});
	</script>
</html>