<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Bakeoff 2</title>
		<style type="text/css">
		/*		This CSS is not required, but recommended.	*/
			body {
				height: 100vh;
				width: 100vw;
				border: none;
				margin: 0px;
				text-align: center;
				display: flex;
			    align-items: center;
			    justify-content: center;
			}
			body.active {
				border-left: 3px #f06 solid;
			}
			footer {
				width: 100vw;
				text-align: center;
				position: absolute;
				bottom: 0px;
				padding: 0.75em;
				border-top: 1px #ddd solid;
			}
			svg {
				border: 1px #ddd solid;
			}
		</style>
		<!-- Two required scripts -->
		<script src="https://cdn.jsdelivr.net/npm/@svgdotjs/svg.js@3.0/dist/svg.min.js"></script>
		<script src="https://dhcs-s25-bakeoff2.glitch.me/framework.js"></script>
		<!-- <script src="./js/framework.js"></script> -->
	</head>
	<body>
		<div id="main"></div>
	</body>
	<script type="text/javascript">
		// =========== This part is required: =========== 
		// This constant can be changed while you are experimenting, but it should be set back to 10 for the Bakeoff:
		const tasksLength = 10;

		// As with Bakeoff 1, this code uses the svg.js library; documentation at: https://svgjs.dev/docs/3.0/
		// Create an svg div that is the specified size, in the div with ID "main". (Centering it on the page is handled by CSS.)
		// The "size" attribute here is specified as a string.
		let svg = SVG().addTo('#main').size(""+canvasSize+"px", ""+canvasSize+"px");

		// Initialize the "judge" object with the number of tasks per trial, your svg drawing area, and a team name.
		const judge = new Judge(tasksLength, svg, "teamName");
		// =========== /end required =========== 

		// Events you can assign handlers to:
		// 		score: when a task is scored
		// 		newTask: when a new task (the set of start and goal positions) is created
		// 		testOver: when all tasks have been fulfilled
		// 		setup: when the judge is first created, and whenever the "reset" button is pressed
		// 		clearField: when the judge removes the squares from the previous round
		// judge.on(eventName, callback) will allow you to register a callback (handler) to any of the above.

		// Other functions you can call:
		// judge.getCurrentTask() will return a "task" object shaped like this:
		//		{
		//			start: {
		//				position: {
		//						x: number,
		//						y: number
		//					},
		//				rotation: number,
		//				size: number,
		//				square: SVG.Rect
		//			},
		//			goal: {
		//				position: {
		//					x: number,
		//					y: number
		//				},
		//				rotation: number,
		//				size: number,
		//				square: SVG.Rect
		//			}
		//		};
		// 
		// judge.getTaskNumber() will return the number (integer) of the current task
		// judge.setup() starts everything in motion.


		//  =========== !!! FOR EXAMPLE !!! =========== 

		// Here are some consts just for this example code:
		const startColor = "#6677ee";
		const goalColor = "#777";

		// And global variables for interaction
		let squareBeingClicked = false;
		let resizeMode = false;
		let rotateMode = false;
		let originalSize = 0;
		let startDragPos = { x: 0, y: 0 };
		let centerPoint = { x: 0, y: 0 };
		let startRotation = 0;
		let resizeHandle = null;
		const MIN_SQUARE_SIZE = 30;

		// These "SVG groups" will hold the squares. I could put other things in these groups, and then everything would move together.
		let manipulator = svg.group();
		let goal = svg.group();

		// Function to update the resize handle position
		function updateResizeHandlePosition() {
			const task = judge.getCurrentTask();
			if (!task || !resizeHandle) return;
			
			const bbox = task.start.square.bbox();
			const handleX = bbox.width - 18;
			const handleY = bbox.height - 18;
			resizeHandle.move(handleX, handleY);
		}

		// Any time the mouse moves over the svg area...
		svg.on("mousemove", (e)=>{
			if (squareBeingClicked) {
				if (rotateMode) {
					const task = judge.getCurrentTask();
					const square = task.start.square;
					const cursorPoint = svg.point(e.clientX, e.clientY);
					
					const currentVector = {
						x: cursorPoint.x - centerPoint.x,
						y: cursorPoint.y - centerPoint.y
					};
					
					const angle = Math.atan2(currentVector.y, currentVector.x) * (180 / Math.PI);
					square.rotate(angle);
					task.start.rotation = angle;
					
					updateResizeHandlePosition();
				}
				else if (resizeMode) {
					const task = judge.getCurrentTask();
					const dx = e.clientX - startDragPos.x;
					const dy = e.clientY - startDragPos.y;
					
					const dragDistance = Math.max(dx, dy);
					const newSize = Math.max(MIN_SQUARE_SIZE, originalSize + dragDistance);
					
					task.start.square.size(newSize, newSize);
					updateResizeHandlePosition();
				} else {
					// Simple center-based dragging without handle updates
					manipulator.center(e.offsetX, e.offsetY);
				}
			}
		});

		// When a new task is assigned, run this...
		judge.on("newTask", () => {
			// get the next task
			let task = judge.getCurrentTask();

			// style the start and goal squares
			task.start.square.fill(startColor);
			task.goal.square.fill('none');
			task.goal.square.stroke(goalColor);

			// Create a group for the square and its handle
			let squareGroup = svg.group();
			squareGroup.add(task.start.square);

			// add the groups
			manipulator.add(squareGroup);
			goal.add(task.goal.square);

			// Create the resize handle
			if (resizeHandle) resizeHandle.remove();
			resizeHandle = svg.group();
			
			// Background box
			const handleBg = svg.rect(18, 18)
				.fill('#ff0000')
				.opacity(0.8)
				.radius(2);
			
			// Add diagonal lines
			const diag1 = svg.line(3, 15, 15, 3)
				.stroke({ color: 'white', width: 1.5, dasharray: '2,1' });
			const diag2 = svg.line(6, 15, 15, 6)
				.stroke({ color: 'white', width: 1.5, dasharray: '2,1' });
			const diag3 = svg.line(9, 15, 15, 9)
				.stroke({ color: 'white', width: 1.5, dasharray: '2,1' });
			
			// Add "R" text
			const rotateText = svg.text("R")
				.font({ size: 8, anchor: 'middle' })
				.fill('white')
				.center(9, 9);
			
			resizeHandle.add(handleBg);
			resizeHandle.add(diag1);
			resizeHandle.add(diag2);
			resizeHandle.add(diag3);
			resizeHandle.add(rotateText);
			
			// Add handle to the square group
			squareGroup.add(resizeHandle);
			
			// Position handle initially
			updateResizeHandlePosition();

			// Handle mousedown on the resize handle or square
			svg.on("mousedown", (e)=> {
				const point = svg.point(e.clientX, e.clientY);
				const square = task.start.square;
				const squareSize = square.width();
				
				// Check if clicking resize handle
				const handleBounds = resizeHandle.bbox();
				if (point.x >= handleBounds.x && point.x <= handleBounds.x + handleBounds.width &&
					point.y >= handleBounds.y && point.y <= handleBounds.y + handleBounds.height) {
					
					if (e.shiftKey) {
						rotateMode = true;
						resizeMode = false;
						
						const bbox = square.bbox();
						centerPoint = {
							x: bbox.x + bbox.width/2,
							y: bbox.y + bbox.height/2
						};
					} else {
						rotateMode = false;
						resizeMode = true;
						originalSize = squareSize;
						startDragPos = { x: e.clientX, y: e.clientY };
					}
					squareBeingClicked = true;
				} else {
					// Regular dragging mode
					rotateMode = false;
					resizeMode = false;
					squareBeingClicked = true;
				}
			});

			// Add mouseup handlers
			svg.on("mouseup", (e)=> {
				squareBeingClicked = false;
				resizeMode = false;
				rotateMode = false;
			});
			
			// Add instructions
			const instructions = svg.text("Hold SHIFT + drag red handle for rotation")
				.font({ size: 10 })
				.fill('#555')
				.move(10, canvasSize - 20);
			
			setTimeout(() => {
				instructions.remove();
			}, 5000);
		});

		// once you've got your handlers set up, start it up:
		judge.setup();
		
		// Add this helper function to find the bottom right corner
		function getBottomRightCorner(corners) {
			// Find the corner with the largest sum of x and y coordinates
			return corners.reduce((bottomRight, vertex) => {
				// Compare using the sum of x and y
				return (vertex.x + vertex.y > bottomRight.x + bottomRight.y) ? vertex : bottomRight;
			}, corners[0]);
		}

		// Helper function for transforming points with a matrix
		function transformPoint(point, matrix) {
			return {
				x: matrix.a * point.x + matrix.c * point.y + matrix.e,
				y: matrix.b * point.x + matrix.d * point.y + matrix.f
			};
		}
	</script>
</html>